{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["Block","props","width","height","x","y","react_default","a","createElement","className","App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","handleKeyPressed","event","key","spacePressed","state","gameOver","rPressed","reset","layDownBlock","handleKeyRelease","handleTouch","asyncToGenerator","regenerator_default","mark","_callee","wrap","_context","prev","next","stop","board","winner","blink","displayMessage","cellScale","distance","update","bind","assertThisInitialized","messageBlink","_this2","length","intervalId","setInterval","setState","yPos","inactiveBlocks","Array","blocksToSpawn","createNewBlocks","document","addEventListener","evt","clearInterval","checkBoard","Math","floor","newTimer","console","log","slice","i","activeBlocks","splice","concat","timeout","_this3","midPoint","push","createBlock","blocks","updateActiveBlocks","renderBlocks","ReactDOM","render","getElementById","id","onKeyPress","onKeyUp","onTouchStart","React","Component","Boolean","window","location","hostname","match","src_App_0","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"kSAIA,SAASA,EAAMC,GAAO,IACXC,EAAuBD,EAAvBC,MAAOC,EAAgBF,EAAhBE,OAAQC,EAAQH,EAARG,EAAGC,EAAKJ,EAALI,EAEzB,OAAQC,EAAAC,EAAAC,cAAA,QAAMN,MAAOA,EAAOC,OAAQA,EAAQC,EAAGA,EAAGC,EAAGA,EAAGI,UAAU,aA8XvDC,cA1XX,SAAAA,EAAYT,GAAO,IAAAU,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAJ,IACfC,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAF,GAAAO,KAAAH,KAAMb,KA+DViB,iBAAmB,SAAAC,GAEO,MAAdA,EAAMC,KAAgBT,EAAKU,cAAiBV,EAAKW,MAAMC,SAKpC,MAAdJ,EAAMC,MAAgBT,EAAKa,UAAYb,EAAKW,MAAMC,WACvDZ,EAAKa,UAAW,EAChBb,EAAKc,UANLd,EAAKU,cAAe,EACpBV,EAAKe,iBApEEf,EA6EnBgB,iBAAmB,SAAAR,GAEG,MAAdA,EAAMC,IACNT,EAAKU,cAAe,EAGD,MAAdF,EAAMC,MACXT,EAAKa,UAAW,IApFLb,EA6FnBiB,YA7FmBhB,OAAAiB,EAAA,EAAAjB,CAAAkB,EAAAvB,EAAAwB,KA6FL,SAAAC,IAAA,OAAAF,EAAAvB,EAAA0B,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,UACLzB,EAAKW,MAAMC,SADN,CAAAW,EAAAE,KAAA,eAAAF,EAAAE,KAAA,EAEAzB,EAAKe,eAFL,OAAAQ,EAAAE,KAAA,eAINzB,EAAKc,QAJC,wBAAAS,EAAAG,SAAAL,MA1FVrB,EAAKW,MAAQ,CACTgB,MAAO,CACH,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAEvBf,UAAU,EACVgB,QAAQ,EACRC,OAAO,EACPC,eAAgB,WAGpB9B,EAAK+B,UAAY,GACjB/B,EAAKgC,SAAWhC,EAAK+B,UAErB/B,EAAKU,cAAe,EACpBV,EAAKa,UAAW,EAEhBb,EAAKiC,OAASjC,EAAKiC,OAAOC,KAAZjC,OAAAkC,EAAA,EAAAlC,CAAAD,IACdA,EAAKiB,YAAcjB,EAAKiB,YAAYiB,KAAjBjC,OAAAkC,EAAA,EAAAlC,CAAAD,IACnBA,EAAKoC,aAAepC,EAAKoC,aAAaF,KAAlBjC,OAAAkC,EAAA,EAAAlC,CAAAD,IA/BLA,mFAqCC,IAAAqC,EAAAlC,KAChBA,KAAKX,OAASW,KAAK4B,UAAY5B,KAAKQ,MAAMgB,MAAMW,OAChDnC,KAAKZ,MAAQY,KAAK4B,UAAY5B,KAAKQ,MAAMgB,MAAM,GAAGW,OAElDnC,KAAKoC,WAAaC,YAAYrC,KAAK8B,OAAQ,KAC3C9B,KAAKsC,SAAS,CACVC,KAAMvC,KAAKX,OAASW,KAAK4B,UACzBY,eAAgBC,MAAM,GACtBC,cAAe,GAChB,kBAAMR,EAAKS,oBAEdC,SAASC,iBAAiB,WAAa,SAAAC,GAAG,OAAIZ,EAAK9B,iBAAiB0C,KACpEF,SAASC,iBAAiB,QAAU,SAAAC,GAAG,OAAIZ,EAAKrB,iBAAiBiC,oDAOjEC,cAAc/C,KAAKoC,2KAmDbpC,KAAKgD,oBAGNhD,KAAKQ,MAAMC,WAERT,KAAKQ,MAAM+B,KAAOvC,KAAK4B,YAAcqB,KAAKC,OAAQlD,KAAKQ,MAAMgB,MAAMW,OAAS,GAAM,GAClFnC,KAAKmD,SAAS,EAAG,IAGZnD,KAAKQ,MAAM+B,KAAOvC,KAAK4B,YAAcqB,KAAKC,MAAO,GAAKlD,KAAKQ,MAAMgB,MAAMW,OAAS,GAAM,IAC3FnC,KAAKmD,SAAS,EAAG,KAGrBnD,KAAK2C,8QAcTS,QAAQC,IAAIrD,KAAKQ,MAAM+B,MACnBf,EAAQxB,KAAKQ,MAAMgB,MAAM8B,QAGpBC,EAAI,cAAGA,EAAIvD,KAAKQ,MAAMgD,aAAarB,4BAClC7C,EAAIU,KAAKQ,MAAMgD,aAAaD,GAAGpE,MAAMG,EACrCC,EAAIS,KAAKQ,MAAMgD,aAAaD,GAAGpE,MAAMI,EAGvCS,KAAKQ,MAAM+B,OAASvC,KAAKX,OAASW,KAAK4B,2BACvCJ,EAAMjC,EAAIS,KAAK4B,WAAWtC,EAAIU,KAAK4B,WAAa,6BAGY,IAAxDJ,EAAOjC,EAAIS,KAAK4B,UAAa,GAAGtC,EAAIU,KAAK4B,4BACzCJ,EAAMjC,EAAIS,KAAK4B,WAAWtC,EAAIU,KAAK4B,WAAa,iCAEhD5B,KAAKQ,MAAMgD,aAAaC,OAAOF,EAAG,aAC5BvD,KAAKsC,SAAS,CAChBI,cAAe1C,KAAKQ,MAAMkC,cAAgB,GAC3C,WACC1C,KAAKsC,SAAS,CACV7B,SAAuC,IAA7BT,KAAKQ,MAAMkC,0BAK7Ba,YAtBwCA,4CA2B9CvD,KAAKsC,SAAS,CAChBC,KAAMvC,KAAKQ,MAAM+B,KAAOvC,KAAK4B,UAC7BJ,MAAOA,EACPgB,eACIxC,KAAKQ,MAAMgC,eAAekB,OAAO1D,KAAKQ,MAAMgD,eACjD,WAEKxD,KAAKQ,MAAM+B,KAAO,IAAMvC,KAAKQ,MAAMC,UACnCT,KAAKsC,SAAS,CACV7B,UAAU,EACVgB,QAAQ,cAKpBzB,KAAK6B,SAAW7B,KAAK4B,UACrBwB,QAAQC,IAAIrD,KAAKQ,MAAM+B,0IASlBG,EAAeiB,GAEhB3D,KAAKQ,MAAMkC,gBAAkBA,GAC7B1C,KAAKsC,SAAS,CACVI,cAAe1C,KAAKQ,MAAMkC,cAAgB,IAKlDK,cAAc/C,KAAKoC,YAEnBpC,KAAKoC,WAAaC,YAAYrC,KAAK8B,OAAQ6B,mCAMvC,IAAAC,EAAA5D,KAEJ+C,cAAc/C,KAAKoC,YAEnBpC,KAAKoC,WAAaC,YAAYrC,KAAK8B,OAAQ,KAG3C9B,KAAKsC,SAAS,CACVd,MAAO,CACH,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAEvBf,UAAU,EACVgB,QAAQ,EACRC,OAAO,EACPC,eAAgB,UAChBY,KAAMvC,KAAKX,OAASW,KAAK4B,UACzBY,eAAgBC,MAAM,GACtBC,cAAe,GAChB,kBAAMkB,EAAKjB,wDAUNrD,EAAGC,GACX,OACIC,EAAAC,EAAAC,cAACR,EAAD,CACIE,MAAOY,KAAK4B,UACZvC,OAAQW,KAAK4B,UACbtC,EAAGA,EACHC,EAAGA,8CASX,IAAMsE,EAAWZ,KAAKC,MAAOlD,KAAKZ,MAAQ,EAAKY,KAAK4B,WAAa5B,KAAK4B,UAClE4B,EAAef,MAAM,GAIzB,OAAQzC,KAAKQ,MAAMkC,eACf,KAAK,EACDc,EAAaM,KAAK9D,KAAK+D,YAAYF,EAAW7D,KAAK4B,UAAW5B,KAAKQ,MAAM+B,OAE7E,KAAK,EACDiB,EAAaM,KAAK9D,KAAK+D,YAAYF,EAAU7D,KAAKQ,MAAM+B,OAE5D,KAAK,EACDiB,EAAaM,KAAK9D,KAAK+D,YAAYF,EAAW7D,KAAK4B,UAAW5B,KAAKQ,MAAM+B,OAIjFvC,KAAKsC,SAAS,CACVkB,aAAcA,qCASdxD,KAAKQ,MAAMC,UAA0C,YAA9BT,KAAKQ,MAAMmB,gBAElCoB,cAAc/C,KAAKoC,YACnBpC,KAAKoC,WAAaC,YAAYrC,KAAKiC,aAAc,KAEjDjC,KAAKsC,SAAS,CACV0B,OAAQhE,KAAKQ,MAAMgD,aAAaE,OAAO1D,KAAKQ,MAAMgC,oBAGtDxC,KAAKiE,qBAELjE,KAAKsC,SAAS,CACV0B,OAAQhE,KAAKQ,MAAMgD,aAAaE,OAAO1D,KAAKQ,MAAMgC,mBAI1DxC,KAAKkE,sDAODlE,KAAKQ,MAAMkB,MACX1B,KAAKsC,SAAS,CACVZ,OAAO,EACPC,eAAgB3B,KAAKQ,MAAMiB,OAAS,SAAW,UAGnDzB,KAAKsC,SAAS,CACVZ,OAAO,EACPC,eAAgBnC,EAAAC,EAAAC,cAAA,uEASxB,IAAM8D,EAAexD,KAAKQ,MAAMgD,aAAaF,QAGzCE,EAAaA,EAAarB,OAAS,GAAGhD,MAAMG,IAAMU,KAAKZ,MAAQY,KAAK4B,UACpE5B,KAAK6B,UAAY7B,KAAK4B,UAGW,IAA5B4B,EAAa,GAAGrE,MAAMG,IAC3BU,KAAK6B,SAAW7B,KAAK4B,WAIzB,IAAK,IAAI2B,EAAI,EAAGA,EAAIC,EAAarB,OAAQoB,IAAK,CAC1C,IAAIhE,EAAIiE,EAAaD,GAAGpE,MAAMI,EAC1BD,EAAIkE,EAAaD,GAAGpE,MAAMG,EAAIU,KAAK6B,SAEvC2B,EAAaD,GAAKvD,KAAK+D,YAAYzE,EAAGC,GAG1CS,KAAKsC,SAAS,CACVkB,aAAcA,2CAQlBW,IAASC,OAAOpE,KAAKQ,MAAMwD,OAAQpB,SAASyB,eAAe,4CAI3D,OACI7E,EAAAC,EAAAC,cAAA,OAAKC,UAAU,QACXH,EAAAC,EAAAC,cAAA,UAAKM,KAAKQ,MAAMmB,gBAChBnC,EAAAC,EAAAC,cAAA,OACIN,MAAOY,KAAKZ,MACZC,OAAQW,KAAKX,OACbiF,GAAG,SACH3E,UAAU,SACV4E,WAAYvE,KAAKI,iBACjBoE,QAASxE,KAAKa,iBACd4D,aAAczE,KAAKc,cAGvBtB,EAAAC,EAAAC,cAAA,UAAKM,KAAKQ,MAAMC,SAAW,0BAA4B,uCArXrDiE,IAAMC,WCEJC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNb,IAASC,OAAO5E,EAAAC,EAAAC,cAACuF,EAAD,MAASrC,SAASyB,eAAe,SD2H3C,kBAAmBa,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.c9e12088.chunk.js","sourcesContent":["import ReactDOM from 'react-dom'\r\nimport React from 'react';\r\nimport './App.css';\r\n\r\nfunction Block(props) {\r\n    const {width, height, x, y} = props;\r\n\r\n    return (<rect width={width} height={height} x={x} y={y} className=\"rect\"/>);\r\n}\r\n\r\nclass App extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            board: [\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n            ],\r\n            gameOver: false,\r\n            winner: false,\r\n            blink: true,\r\n            displayMessage: 'STACKER',\r\n        };\r\n\r\n        this.cellScale = 50;\r\n        this.distance = this.cellScale;\r\n\r\n        this.spacePressed = false;\r\n        this.rPressed = false;\r\n\r\n        this.update = this.update.bind(this);\r\n        this.handleTouch = this.handleTouch.bind(this);\r\n        this.messageBlink = this.messageBlink.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Initializes values when component mounts\r\n     */\r\n    componentDidMount() {\r\n        this.height = this.cellScale * this.state.board.length;\r\n        this.width = this.cellScale * this.state.board[0].length;\r\n\r\n        this.intervalId = setInterval(this.update, 150);\r\n        this.setState({\r\n            yPos: this.height - this.cellScale,\r\n            inactiveBlocks: Array(0),\r\n            blocksToSpawn: 3,\r\n        }, () => this.createNewBlocks());\r\n\r\n        document.addEventListener(\"keypress\", (evt => this.handleKeyPressed(evt)));\r\n        document.addEventListener(\"keyup\", (evt => this.handleKeyRelease(evt)));\r\n    }\r\n\r\n    /**\r\n     * When component unmounts\r\n     */\r\n    componentWillUnmount() {\r\n        clearInterval(this.intervalId);\r\n    }\r\n\r\n    /**\r\n     * Handles key presses\r\n     *\r\n     * @param event used to access which key has been pressed\r\n     */\r\n    handleKeyPressed = event => {\r\n            // IF SPACE key is pressed and game is not over\r\n            if (event.key === ' ' && !this.spacePressed && !this.state.gameOver) {\r\n                this.spacePressed = true;\r\n                this.layDownBlock();\r\n            }\r\n            // IF R key is pressed and game is over\r\n            else if (event.key === 'r' && !this.rPressed && this.state.gameOver) {\r\n                this.rPressed = true;\r\n                this.reset();\r\n            }\r\n    };\r\n\r\n    handleKeyRelease = event => {\r\n        // IF SPACE key is pressed and game is not over\r\n        if (event.key === ' ') {\r\n            this.spacePressed = false;\r\n        }\r\n        // IF R key is pressed and game is over\r\n        else if (event.key === 'r') {\r\n            this.rPressed = false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Handles touch presses\r\n     *\r\n     * @returns {Promise<void>}\r\n     */\r\n    handleTouch = async () => {\r\n        if (!this.state.gameOver) {\r\n            await this.layDownBlock();\r\n        } else {\r\n            this.reset();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks board to lay block down, checks to see if timer should be sped up, and adds new blocks\r\n     *\r\n     * @returns {Promise<void>}\r\n     */\r\n    async layDownBlock() {\r\n        await this.checkBoard();\r\n\r\n        // IF the game is not over (game state may have changed in checkBoard)\r\n        if (!this.state.gameOver) {\r\n            // IF y position has reached 2/3 of the board\r\n            if (this.state.yPos / this.cellScale === Math.floor(((this.state.board.length - 1)) / 3)) {\r\n                this.newTimer(2, 85);   // INCREASE speed\r\n            }\r\n            // IF y position has reached 1/3 of the board\r\n            else if (this.state.yPos / this.cellScale === Math.floor((2 * (this.state.board.length - 1)) / 3)) {\r\n                this.newTimer(3, 100);  // INCREASE speed\r\n            }\r\n\r\n            this.createNewBlocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks below active blocks\r\n     *  IF there are no blocks below active blocks:\r\n     *      DECREMENT blocks to spawn\r\n     *      IF blocks to spawn equals 0\r\n     *          GAME IS OVER\r\n     *  ELSE:\r\n     *      UPDATE BOARD\r\n     */\r\n    async checkBoard() {\r\n        console.log(this.state.yPos);\r\n        let board = this.state.board.slice();\r\n\r\n        // FOREACH active block\r\n        for (let i = 0; i < this.state.activeBlocks.length; i++) {\r\n            const x = this.state.activeBlocks[i].props.x;\r\n            const y = this.state.activeBlocks[i].props.y;\r\n\r\n            // IF current y position is at the bottom of the board\r\n            if (this.state.yPos === this.height - this.cellScale) {\r\n                board[y / this.cellScale][x / this.cellScale] = 1;\r\n            } else {\r\n                // IF active block is under a block\r\n                if (board[(y / this.cellScale) + 1][x / this.cellScale] === 1) {\r\n                    board[y / this.cellScale][x / this.cellScale] = 1;\r\n                } else {\r\n                    this.state.activeBlocks.splice(i, 1);   // REMOVE block from active blocks\r\n                    await this.setState({\r\n                        blocksToSpawn: this.state.blocksToSpawn - 1,  // DECREMENT blocks to spawn\r\n                    }, function () {\r\n                        this.setState({\r\n                            gameOver: this.state.blocksToSpawn === 0  // IF blocks to spawn is 0, the game is over\r\n                                                                      // player lost\r\n                        });\r\n                    });\r\n\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n\r\n        await this.setState({\r\n            yPos: this.state.yPos - this.cellScale, // SET new y position\r\n            board: board,\r\n            inactiveBlocks:\r\n                this.state.inactiveBlocks.concat(this.state.activeBlocks)   // INSERT active blocks to inactive blocks\r\n        }, function () {\r\n            // IF y position is less than 0 and game is not over\r\n            if (this.state.yPos < 0 && !this.state.gameOver) {\r\n                this.setState({\r\n                    gameOver: true, // game is over\r\n                    winner: true    // player won\r\n                });\r\n            }\r\n        });\r\n\r\n        this.distance = this.cellScale;\r\n        console.log(this.state.yPos);\r\n    }\r\n\r\n    /**\r\n     * SETS new update interval\r\n     *\r\n     * @param blocksToSpawn value that will be compared to the current value of blocks to spawn\r\n     * @param timeout new timeout value\r\n     */\r\n    newTimer(blocksToSpawn, timeout) {\r\n        // IF current blocks to spawn is equal to blocks to spawn\r\n        if (this.state.blocksToSpawn === blocksToSpawn) {\r\n            this.setState({\r\n                blocksToSpawn: this.state.blocksToSpawn - 1 // DECREMENT blocks to spawn\r\n            });\r\n        }\r\n\r\n        // SET new interval\r\n        clearInterval(this.intervalId);\r\n\r\n        this.intervalId = setInterval(this.update, timeout);\r\n    }\r\n\r\n    /**\r\n     * RESET game to initial state\r\n     */\r\n    reset() {\r\n        // SET new interval\r\n        clearInterval(this.intervalId);\r\n\r\n        this.intervalId = setInterval(this.update, 150);\r\n\r\n        // RESET state to initial state\r\n        this.setState({\r\n            board: [\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 0, 0, 0, 0],\r\n            ],\r\n            gameOver: false,\r\n            winner: false,\r\n            blink: true,\r\n            displayMessage: 'STACKER',\r\n            yPos: this.height - this.cellScale,\r\n            inactiveBlocks: Array(0),\r\n            blocksToSpawn: 3,\r\n        }, () => this.createNewBlocks());\r\n    }\r\n\r\n    /**\r\n     * Create new block\r\n     *\r\n     * @param x x position of block\r\n     * @param y y position ob block\r\n     * @returns {*} new block element\r\n     */\r\n    createBlock(x, y) {\r\n        return (\r\n            <Block\r\n                width={this.cellScale}\r\n                height={this.cellScale}\r\n                x={x}\r\n                y={y}\r\n            />\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new set of block elements\r\n     */\r\n    createNewBlocks() {\r\n        const midPoint = Math.floor((this.width / 2) / this.cellScale) * this.cellScale;\r\n        let activeBlocks = Array(0);\r\n\r\n        // depending on the amount of blocks to spawn, push n blocks to active blocks\r\n        // eslint-disable-next-line\r\n        switch (this.state.blocksToSpawn) {\r\n            case 3:\r\n                activeBlocks.push(this.createBlock(midPoint - this.cellScale, this.state.yPos));\r\n            // eslint-disable-next-line\r\n            case 2:\r\n                activeBlocks.push(this.createBlock(midPoint, this.state.yPos));\r\n            // eslint-disable-next-line\r\n            case 1:\r\n                activeBlocks.push(this.createBlock(midPoint + this.cellScale, this.state.yPos));\r\n                break;\r\n        }\r\n\r\n        this.setState({\r\n            activeBlocks: activeBlocks\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates active blocks\r\n     */\r\n    update() {\r\n        // IF the game is over and display message is still 'STACKER'\r\n        if (this.state.gameOver && this.state.displayMessage === 'STACKER') {\r\n            // SET new interval\r\n            clearInterval(this.intervalId);\r\n            this.intervalId = setInterval(this.messageBlink, 250);\r\n\r\n            this.setState({\r\n                blocks: this.state.activeBlocks.concat(this.state.inactiveBlocks)\r\n            });\r\n        } else {\r\n            this.updateActiveBlocks();\r\n\r\n            this.setState({\r\n                blocks: this.state.activeBlocks.concat(this.state.inactiveBlocks)\r\n            });\r\n        }\r\n\r\n        this.renderBlocks();\r\n    }\r\n\r\n    /**\r\n     * Blinking effect for display message once game is over\r\n     */\r\n    messageBlink() {\r\n        if (this.state.blink) {\r\n            this.setState({\r\n                blink: false,\r\n                displayMessage: this.state.winner ? 'WINNER' : 'LOSER'\r\n            });\r\n        } else {\r\n            this.setState({\r\n                blink: true,\r\n                displayMessage: <span>&nbsp;&nbsp;</span>\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move active blocks\r\n     */\r\n    updateActiveBlocks() {\r\n        const activeBlocks = this.state.activeBlocks.slice();\r\n\r\n        // IF rightmost block is at the rightmost cell\r\n        if (activeBlocks[activeBlocks.length - 1].props.x === this.width - this.cellScale) {\r\n            this.distance = -this.cellScale;\r\n        }\r\n        // IF leftmost block is at the leftmost cell\r\n        else if (activeBlocks[0].props.x === 0) {\r\n            this.distance = this.cellScale;\r\n        }\r\n\r\n        // move active blocks\r\n        for (let i = 0; i < activeBlocks.length; i++) {\r\n            let y = activeBlocks[i].props.y;\r\n            let x = activeBlocks[i].props.x + this.distance;\r\n\r\n            activeBlocks[i] = this.createBlock(x, y);\r\n        }\r\n\r\n        this.setState({\r\n            activeBlocks: activeBlocks\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Renders all block elements\r\n     */\r\n    renderBlocks() {\r\n        ReactDOM.render(this.state.blocks, document.getElementById('canvas'));\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"root\">\r\n                <h1>{this.state.displayMessage}</h1>\r\n                <svg\r\n                    width={this.width}\r\n                    height={this.height}\r\n                    id='canvas'\r\n                    className=\"canvas\"\r\n                    onKeyPress={this.handleKeyPressed}\r\n                    onKeyUp={this.handleKeyRelease}\r\n                    onTouchStart={this.handleTouch}\r\n                >\r\n                </svg>\r\n                <h2>{this.state.gameOver ? \"PRESS 'R' TO PLAY AGAIN\" : \"PRESS 'SPACE' TO SET BLOCKS\"}</h2>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" messageBlink.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}